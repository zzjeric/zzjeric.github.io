<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eric&#39;s blog</title>
  
  <subtitle>生如逆旅 一苇以航</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-21T06:38:19.600Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Eric Zhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于kubeadm搭建k8s集群v1.16</title>
    <link href="http://example.com/2020/02/01/k8s_cluster_deploy_116/"/>
    <id>http://example.com/2020/02/01/k8s_cluster_deploy_116/</id>
    <published>2020-02-01T05:33:33.000Z</published>
    <updated>2021-06-21T06:38:19.600Z</updated>
    
    <content type="html"><![CDATA[<p>Kubeadm是k8s官方提供的一个k8s集群搭建和管理工具，能简化很多配置工作。</p><p>参考： <a href="https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm/">https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm/</a></p><h3><span id="1-软件版本">1 软件版本：</span></h3><ul><li>Kubeadm：</li><li>K8s：v1.16</li><li>Os： Centos 7.x</li><li>Kernel： Linux 5.3.7-1.el7.elrepo.x86_64</li></ul><h3><span id="2-配置虚拟机环境">2  配置虚拟机环境：</span></h3><h5><span id="21-检查centos内核版本所有节点">2.1 检查centos内核版本（所有节点）：</span></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/redhat-release</span><br><span class="line">CentOS Linux release 7.2.1511 (Core) </span><br><span class="line">[root@localhost ~]# uname -sr</span><br><span class="line">Linux 3.10.0-327.el7.x86_64</span><br></pre></td></tr></table></figure><p>可以看到用的centos7.2，内核是3.x的，版本有点低，如果需要启用ipvs，需要升级内核到最新版本（或者使用Centos 7.6、7.8等比较新的os），升级后内核版本为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node1 ~]# uname -sr</span><br><span class="line">Linux 5.3.7-1.el7.elrepo.x86_64</span><br></pre></td></tr></table></figure><p>升级centos内核：</p><p>在 CentOS 7 上启用 ELRepo 仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line">rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</span><br></pre></td></tr></table></figure><p>使用下面的命令列出可用的内核相关包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --disablerepo=&quot;*&quot; --enablerepo=&quot;elrepo-kernel&quot; list available</span><br></pre></td></tr></table></figure><p>安装最新的主线稳定内核：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo=elrepo-kernel install kernel-ml</span><br></pre></td></tr></table></figure><p>设置grub默认内核版本：</p><p>编辑/etc/default/grub 文件，内容替换为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GRUB_TIMEOUT=5</span><br><span class="line">GRUB_DEFAULT=0</span><br><span class="line">GRUB_DISABLE_SUBMENU=true</span><br><span class="line">GRUB_TERMINAL_OUTPUT=&quot;console&quot;</span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;rd.lvm.lv=centos/root rd.lvm.lv=centos/swap crashkernel=auto rhgb quiet&quot;</span><br><span class="line">GRUB_DISABLE_RECOVERY=&quot;true&quot;</span><br></pre></td></tr></table></figure><p>运行下面的命令来重新创建内核配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><p>然后reboot重启，完成后，用uname -sr重新查看内核版本是否已升级。</p><p>参考：<a href="https://linux.cn/article-8310-1.html">https://linux.cn/article-8310-1.html</a></p><h5><span id="22-配置ntp-服务器所有节点">2.2 配置NTP 服务器（所有节点）</span></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install ntp</span><br><span class="line">systemctl start ntpd</span><br><span class="line">https://blog.csdn.net/zhangjie0412/article/details/77935584</span><br></pre></td></tr></table></figure><h5><span id="23-配置hosts所有节点">2.3 配置hosts（所有节点）</span></h5><p>在/所有节点的etc/hosts文件中，配置各个节点的ip<br><code>cat /etc/hosts</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">172.18.10.18 node1</span><br><span class="line">172.18.10.19 node2</span><br><span class="line">172.18.10.20 node3</span><br></pre></td></tr></table></figure><p>其中node1作为master节点，node2和node3作为普通节点。</p><h5><span id="24-修改或禁用防火墙开放端口所有节点">2.4 修改或禁用防火墙开放端口（所有节点）</span></h5><p>如果各个主机启用了防火墙，需要开放Kubernetes各个组件所需要的端口，可以查看Installing kubeadm中的”Check required ports”一节。 简单起见在各节点禁用防火墙：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><p>生产环境下，这里需要考虑一下。</p><p>禁用SELINUX：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line">vi /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure><p>创建/etc/sysctl.d/k8s.conf文件，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure><p>执行命令使修改生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe br_netfilter</span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br></pre></td></tr></table></figure><h5><span id="25-配置ipvs所有节点">2.5 配置ipvs（所有节点）</span></h5><p>kube-proxy开启ipvs 需要加载一些内核模块，在5.3.7的内核版本，nf_conntrack_ipv4被nf_contrack代替，所以使用下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span><br><span class="line">#!/bin/bash</span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack</span><br><span class="line">EOF</span><br><span class="line">chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack</span><br></pre></td></tr></table></figure><p>各个节点安装ipset和ipvsadm：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install ipset</span><br><span class="line">yum install ipvsadm</span><br></pre></td></tr></table></figure><h5><span id="26-安装docker所有节点">2.6 安装docker（所有节点）</span></h5><p>安装docker的yum源:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>查看可用的docker版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce.x86_64  --showduplicates |sort -r</span><br></pre></td></tr></table></figure><p>在各节点安装docker最新的的19.03.4版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line">yum install -y --setopt=obsoletes=0 \</span><br><span class="line">  docker-ce-19.03.4-3.el7</span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>确认一下iptables filter表中FOWARD链的默认策略(pllicy)为ACCEPT。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -nvL</span><br></pre></td></tr></table></figure><p>修改docker cgroup driver为systemd:</p><p>创建或修改/etc/docker/daemon.json：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启docker：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>用下面的命令验证一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker info | grep Cgroup</span><br><span class="line">Cgroup Driver: system</span><br></pre></td></tr></table></figure><h5><span id="27-关闭swap所有节点">2.7 关闭swap（所有节点）</span></h5><p>Kubernetes 1.8开始要求关闭系统的Swap，如果不关闭，默认配置下kubelet将无法启动</p><p>关闭系统的Swap方法如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure><p>修改 /etc/fstab 文件，注释掉 SWAP 的自动挂载，使用free -m确认swap已经关闭。 swappiness参数调整，修改/etc/sysctl.d/k8s.conf添加下面一行：</p><p>vm.swappiness=0</p><p>执行sysctl -p /etc/sysctl.d/k8s.conf使修改生效。</p><h5><span id="28-安装kubeadm和kubelet所有节点">2.8 安装kubeadm和kubelet（所有节点）</span></h5><p>配置repo：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg</span><br><span class="line">        https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br><span class="line">yum install -y kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><p>在各节点开机启动kubelet服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable kubelet.service</span><br></pre></td></tr></table></figure><h3><span id="3-使用kubeadm部署k8s">3 使用kubeadm部署k8s</span></h3><h5><span id="31-部署master节点">3.1 部署master节点</span></h5><p>3.1.1 使用kubeadm init 初始化master 节点<br>使用kubeadm config print init-defaults可以打印集群初始化默认的使用的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">================</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta2</span></span><br><span class="line"><span class="attr">bootstrapTokens:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">groups:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">system:bootstrappers:kubeadm:default-node-token</span></span><br><span class="line"><span class="attr">token:</span> <span class="string">abcdef.0123456789abcdef</span></span><br><span class="line"><span class="attr">ttl:</span> <span class="string">24h0m0s</span></span><br><span class="line"><span class="attr">usages:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">signing</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">authentication</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">InitConfiguration</span></span><br><span class="line"><span class="attr">localAPIEndpoint:</span></span><br><span class="line"><span class="attr">advertiseAddress:</span> <span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span></span><br><span class="line"><span class="attr">bindPort:</span> <span class="number">6443</span></span><br><span class="line"><span class="attr">nodeRegistration:</span></span><br><span class="line"><span class="attr">criSocket:</span> <span class="string">/var/run/dockershim.sock</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">node1</span></span><br><span class="line"><span class="attr">taints:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"><span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiServer:</span></span><br><span class="line"><span class="attr">timeoutForControlPlane:</span> <span class="string">4m0s</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta2</span></span><br><span class="line"><span class="attr">certificatesDir:</span> <span class="string">/etc/kubernetes/pki</span></span><br><span class="line"><span class="attr">clusterName:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">controllerManager:</span> &#123;&#125;</span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">CoreDNS</span></span><br><span class="line"><span class="attr">etcd:</span></span><br><span class="line"><span class="attr">local:</span></span><br><span class="line"><span class="attr">dataDir:</span> <span class="string">/var/lib/etcd</span></span><br><span class="line"><span class="attr">imageRepository:</span> <span class="string">k8s.gcr.io</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="string">v1.16.0</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line"><span class="attr">dnsDomain:</span> <span class="string">cluster.local</span></span><br><span class="line"><span class="attr">serviceSubnet:</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.0</span><span class="string">/12</span></span><br><span class="line"><span class="attr">scheduler:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>从默认的配置中可以看到，可以使用imageRepository定制在集群初始化时拉取k8s所需镜像的地址。基于默认配置定制出本次使用kubeadm初始化集群所需的配置文件kubeadm.yaml：<br>（注意修改advertiseAddress和kubernetsversion，nodesubet可以自己定义）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">advertiseAddress: 172.18.10.18</span><br><span class="line">bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">taints:</span><br><span class="line">- effect: PreferNoSchedule</span><br><span class="line">key: node-role.kubernetes.io/master</span><br><span class="line">---</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta2</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: v1.16.0</span><br><span class="line">networking:</span><br><span class="line">podSubnet: 10.244.0.0/16</span><br></pre></td></tr></table></figure><p>使用kubeadm默认配置初始化的集群，会在master节点打上node-role.kubernetes.io/master:NoSchedule的污点，阻止master节点接受调度运行工作负载。这里测试环境只有两个节点，所以将这个taint修改为node-role.kubernetes.io/master:PreferNoSchedule，意思是pod会优先调度到普通节点，普通节点不够用master节点也可以运行业务pod。</p><p>参考： <a href="https://blog.frognew.com/2018/05/taint-and-toleration.html">https://blog.frognew.com/2018/05/taint-and-toleration.html</a></p><p>在开始初始化集群之前可以使用kubeadm config images pull预先在各个节点上拉取所k8s需要的docker镜像。</p><p>接下来使用kubeadm初始化集群，选择node1作为Master Node，在node1上执行下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --config kubeadm.yaml --ignore-preflight-errors=Swap</span><br></pre></td></tr></table></figure><p>执行成功后，会打印出这段说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 172.18.10.18:6443 --token ynmb9s.8darvwxj0y6klgj4 \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:345eeb7602eb6133ad032c8515f1d4a7a0d4180759893b32ddf1c043c9a73770 </span><br></pre></td></tr></table></figure><p>这里面提示要执行下面命令生成配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>（只在master节点执行即可）</p><p>另外给了 普通node节点加入集群的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 172.18.10.18:6443 --token ynmb9s.8darvwxj0y6klgj4 \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:345eeb7602eb6133ad032c8515f1d4a7a0d4180759893b32ddf1c043c9a73770 </span><br></pre></td></tr></table></figure><p>查看一下集群状态，确认个组件都处于healthy状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get cs</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME                 STATUS    MESSAGE             ERROR</span><br><span class="line">controller-manager   Healthy   ok                  </span><br><span class="line">scheduler            Healthy   ok                  </span><br><span class="line">etcd-0               Healthy   &#123;&quot;health&quot;:&quot;true&quot;&#125;</span><br></pre></td></tr></table></figure><p>集群初始化如果遇到问题，可以使用下面的命令进行清理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubeadm reset</span><br><span class="line">ifconfig cni0 down</span><br><span class="line">ip link delete cni0</span><br><span class="line">ifconfig flannel.1 down</span><br><span class="line">ip link delete flannel.1</span><br><span class="line">rm -rf /var/lib/cni/</span><br></pre></td></tr></table></figure><p>这些清理命令同样适用于从节点，清理需谨慎。</p><p>3.1.2 在主节点安装flannel network add-on 网络插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/k8s/</span><br><span class="line">cd ~/k8s</span><br><span class="line">curl -O https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line">kubectl apply -f  kube-flannel.yml</span><br></pre></td></tr></table></figure><p>成功后打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.extensions/kube-flannel-ds-amd64 created</span><br><span class="line">daemonset.extensions/kube-flannel-ds-arm64 created</span><br><span class="line">daemonset.extensions/kube-flannel-ds-arm created</span><br><span class="line">daemonset.extensions/kube-flannel-ds-ppc64le created</span><br><span class="line">daemonset.extensions/kube-flannel-ds-s390x created</span><br></pre></td></tr></table></figure><p>如果Node有多个网卡的话，参考lannel issues 39701，目前需要在kube-flannel.yml中使用–iface参数指定集群主机内网网卡的名称，否则可能会出现dns无法解析。需要将kube-flannel.yml下载到本地，flanneld启动参数加上–iface=<iface-name></iface-name></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">containers:</span><br><span class="line">      - name: kube-flannel</span><br><span class="line">        image: quay.io/coreos/flannel:v0.11.0-amd64</span><br><span class="line">        command:</span><br><span class="line">        - /opt/bin/flanneld</span><br><span class="line">        args:</span><br><span class="line">        - --ip-masq</span><br><span class="line">        - --kube-subnet-mgr</span><br><span class="line">        - --iface=eth1</span><br></pre></td></tr></table></figure><p>使用kubectl get pod –all-namespaces -o wide确保所有的Pod都处于Running状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n kube-system</span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">coredns-5c98db65d4-dr8lf        1/1     Running   0          52m</span><br><span class="line">coredns-5c98db65d4-lp8dg        1/1     Running   0          52m</span><br><span class="line">etcd-node1                      1/1     Running   0          51m</span><br><span class="line">kube-apiserver-node1            1/1     Running   0          51m</span><br><span class="line">kube-controller-manager-node1   1/1     Running   0          51m</span><br><span class="line">kube-flannel-ds-amd64-mm296     1/1     Running   0          44s</span><br><span class="line">kube-proxy-kchkf                1/1     Running   0          52m</span><br><span class="line">kube-scheduler-node1            1/1     Running   0          51m</span><br></pre></td></tr></table></figure><p>测试集群DNS是否可用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run curl --image=radial/busyboxplus:curl -it</span><br></pre></td></tr></table></figure><p>进入后执行nslookup kubernetes.default确认解析正常:</p><p>nslookup kubernetes.default</p><h5><span id="32-将普通node节点加入集群">3.2 将普通node节点加入集群</span></h5><p>很简单，只需要在普通node节点，执行上面给出的join命令即可（注意一定要参考2.7节关闭swap）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 172.18.10.18:6443 --token ynmb9s.8darvwxj0y6klgj4 \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:345eeb7602eb6133ad032c8515f1d4a7a0d4180759893b32ddf1c043c9a73770 </span><br></pre></td></tr></table></figure><p>在master节点通过kubectl get node 查看：</p><h5><span id="33-怎样从集群中移除node">3.3 怎样从集群中移除node</span></h5><p>如果需要从集群中移除node2这个Node执行下面的命令：</p><p>在master节点上执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl drain node2 --delete-local-data --force --ignore-daemonsets</span><br><span class="line">kubectl delete node node2</span><br></pre></td></tr></table></figure><p>在node2上执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubeadm reset</span><br><span class="line">ifconfig cni0 down</span><br><span class="line">ip link delete cni0</span><br><span class="line">ifconfig flannel.1 down</span><br><span class="line">ip link delete flannel.1</span><br><span class="line">rm -rf /var/lib/cni/</span><br></pre></td></tr></table></figure><p>在node1上执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete node node2</span><br></pre></td></tr></table></figure><h3><span id="4-安装后配置">4 安装后配置</span></h3><h5><span id="41-kube-proxy开启ipvs">4.1 kube-proxy开启ipvs</span></h5><p>在master节点，修改ConfigMap的kube-system/kube-proxy中的config.conf，mode: “ipvs”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit cm kube-proxy -n kube-system</span><br></pre></td></tr></table></figure><p>之后重启各个节点上的kube-proxy pod，在master节点执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n kube-system | grep kube-proxy | awk &#x27;&#123;system(&quot;kubectl delete pod &quot;$1&quot; -n kube-system&quot;)&#125;&#x27;</span><br></pre></td></tr></table></figure><p>运行下面的命令检查一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n kube-system | grep kube-proxy</span><br></pre></td></tr></table></figure><p>日志中打印出了Using ipvs Proxier，说明ipvs模式已经开启</p><h3><span id="5-插件安装">5 插件安装</span></h3><h5><span id="51-安装helm">5.1 安装helm</span></h5><p>Helm是k8s 的包管理器，类似于yum和apt-get，有了helm后，安装k8s的一些插件会很容易。<br>Helm由客户端命helm令行工具和服务端tiller组成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://get.helm.sh/helm-v2.14.1-linux-amd64.tar.gz</span><br><span class="line">tar -zxvf helm-v2.14.1-linux-amd64.tar.gz</span><br><span class="line">cd linux-amd64/</span><br><span class="line">cp helm /usr/local/bin/</span><br></pre></td></tr></table></figure><p>因为Kubernetes APIServer开启了RBAC访问控制，所以需要创建tiller使用的service account: tiller并分配合适的角色给它。 详细内容可以查看helm文档中的Role-based Access Control。 这里简单起见直接分配cluster-admin这个集群内置的ClusterRole给它。创建helm-rbac.yaml文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tiller</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="string">-f</span> <span class="string">helm-rbac.yaml</span></span><br><span class="line"><span class="string">serviceaccount/tiller</span> <span class="string">created</span></span><br><span class="line"><span class="string">clusterrolebinding.rbac.authorization.k8s.io/tiller</span> <span class="string">created</span></span><br></pre></td></tr></table></figure><p>接下来使用helm部署tiller:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm init --service-account tiller --output yaml | sed &#x27;s@apiVersion: extensions/v1beta1@apiVersion: apps/v1@&#x27; | sed &#x27;s@ replicas: 1@ replicas: 1\n selector: &#123;&quot;matchLabels&quot;: &#123;&quot;app&quot;: &quot;helm&quot;, &quot;name&quot;: &quot;tiller&quot;&#125;&#125;@&#x27; | kubectl apply -f -</span><br></pre></td></tr></table></figure><p>tiller默认被部署在k8s集群中的kube-system这个namespace下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n kube-system -l app=helm</span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">tiller-deploy-c4fd4cd68-dwkhv   1/1     Running   0          83s</span><br></pre></td></tr></table></figure><p>helm version</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Client: &amp;version.Version&#123;SemVer:&quot;v2.14.1&quot;, GitCommit:&quot;5270352a09c7e8b6e8c9593002a73535276507c0&quot;, GitTreeState:&quot;clean&quot;&#125;</span><br><span class="line">Server: &amp;version.Version&#123;SemVer:&quot;v2.14.1&quot;, GitCommit:&quot;5270352a09c7e8b6e8c9593002a73535276507c0&quot;, GitTreeState:&quot;clean&quot;&#125;</span><br></pre></td></tr></table></figure><p>为了拉取速度快些，可以在master节点上修改helm chart仓库的地址为azure提供的镜像地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helmrepo add stable http://mirror.azure.cn/kubernetes/charts</span><br><span class="line">&quot;stable&quot; has been added to your repositories</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">helm repo list</span><br><span class="line">NAME    URL                                     </span><br><span class="line">stable  http://mirror.azure.cn/kubernetes/charts</span><br><span class="line">local   http://127.0.0.1:8879/charts</span><br></pre></td></tr></table></figure><h5><span id="52-部署nginx-ingress">5.2 部署Nginx Ingress</span></h5><p>为了便于将集群中的服务暴露到集群外部，需要使用Ingress。</p><p>将master节点（node1）做为边缘节点，打上Label：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node node1 node-role.kubernetes.io/edge=</span><br></pre></td></tr></table></figure><p>stable/nginx-ingress chart的值文件ingress-nginx.yaml如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">controller:</span></span><br><span class="line">  <span class="attr">replicaCount:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">node-role.kubernetes.io/edge:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAntiAffinity:</span></span><br><span class="line">        <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchExpressions:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">              <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">              <span class="attr">values:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">nginx-ingress</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">component</span></span><br><span class="line">              <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">              <span class="attr">values:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">controller</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">PreferNoSchedule</span></span><br><span class="line"><span class="attr">defaultBackend:</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">node-role.kubernetes.io/edge:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">Exists</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">PreferNoSchedule</span></span><br></pre></td></tr></table></figure><p>nginx ingress controller的副本数replicaCount为1，将被调度到node1这个边缘节点上。这里并没有指定nginx ingress controller service的externalIPs，而是通过hostNetwork: true设置nginx ingress controller使用宿主机网络。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">helm repo update</span><br><span class="line"></span><br><span class="line">helm install stable/nginx-ingress \</span><br><span class="line">-n nginx-ingress \</span><br><span class="line">--namespace ingress-nginx  \</span><br><span class="line">-f ingress-nginx.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后get pod查看下pod 状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n ingress-nginx -o wide</span><br></pre></td></tr></table></figure><p>pod状态为running后，可以在外面访问<a href="http://172.18.10.18返回default/">http://172.18.10.18返回default</a> backend，则部署完成。<br>5.3 安装k8s web ui （dashboard）<br>我之前使用helm安装的dashboard 1.10版本，然后很多页面都报错404 not found，后面发现是因为安装的dashboard版本有点低，不适配1.16，安装最新的v2.0.0-beta4这个版本就可以完美适配 1.16</p><p>安装只需要执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta4/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure><p>参考下面链接中说明 创建用户 获取token， 这个教程创建的用户有最高权限<br><a href="https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md">https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md</a></p><p>Create Service Account<br>We are creating Service Account with name admin-user in namespace kubernetes-dashboard first.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">Create ClusterRoleBinding</span><br><span class="line">In most cases after provisioning our cluster using kops or kubeadm or any other popular tool, the ClusterRole admin-Role already exists in the cluster. We can use it and create only ClusterRoleBinding for our ServiceAccount.</span><br><span class="line">NOTE: apiVersion of ClusterRoleBinding resource may differ between Kubernetes versions. Prior to Kubernetes v1.8 the apiVersion was rbac.authorization.k8s.io/v1beta1.</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure><p>获取token:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk &#x27;&#123;print $1&#125;&#x27;)</span><br></pre></td></tr></table></figure><p>通过ingress暴露服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">ingress-kube-dashboard</span></span><br><span class="line"><span class="attr">annotations:</span></span><br><span class="line"><span class="comment"># use the shared ingress-nginx</span></span><br><span class="line"><span class="attr">kubernetes.io/ingress.class:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line"><span class="attr">nginx.ingress.kubernetes.io/ssl-redirect:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="attr">nginx.ingress.kubernetes.io/backend-protocol:</span> <span class="string">&quot;HTTPS&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">tls:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">k8s.redtea.com</span></span><br><span class="line"><span class="attr">secretName:</span> <span class="string">redtea-com-tls-secret</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">host:</span> <span class="string">k8s.redtea.com</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line"><span class="attr">paths:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">backend:</span></span><br><span class="line"><span class="attr">serviceName:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">servicePort:</span> <span class="number">443</span></span><br></pre></td></tr></table></figure><p>执行kubectl apply -f ingress-dashboard.yaml即可。</p><p>ingress用法参考： <a href="https://qhh.me/2019/08/12/%E4%BD%BF%E7%94%A8-Kubernetes-Ingress-%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1/">https://qhh.me/2019/08/12/%E4%BD%BF%E7%94%A8-Kubernetes-Ingress-%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1/</a></p><p>后面就可以通过访问<br><a href="https://k8s.redtea.com/">https://k8s.redtea.com</a><br>通过GUI 查看和管理集群。</p><h3><span id="6-一些注意点">6 一些注意点</span></h3><h5><span id="1-kube-proxy开启ipvs-需要加载一些内核模块在537的内核版本nf_conntrack_ipv4被nf_contrack代替所以使用下面的命令">1. kube-proxy开启ipvs 需要加载一些内核模块，在5.3.7的内核版本，nf_conntrack_ipv4被nf_contrack代替，所以使用下面的命令：</span></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF</span><br><span class="line">#!/bin/bash</span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack</span><br><span class="line">EOF</span><br><span class="line">chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack</span><br></pre></td></tr></table></figure><h5><span id="2-从节点在加入主节点之前必须按照27-中的说明把swap关掉">2. 从节点在加入主节点之前，必须按照2.7 中的说明，把swap关掉</span></h5><h5><span id="3-312安装pod-network配置flannel-应该只需要在主节点执行从节点不需要">3. 3.1.2安装Pod network配置flannel 应该只需要在主节点执行，从节点不需要</span></h5><h5><span id="4-helm安装tiller报错-no-resource-found可以参考该文章解决httpsgithubcomhelmhelmissues6374使用这个命令安装helm-init-service-account-tiller-output-yaml-sed-sapiversion-extensionsv1beta1apiversion-appsv1-sed-s-replicas-1-replicas-1n-selector-matchlabels-app-helm-name-tiller-kubectl-apply-f-">4. helm安装tiller报错 no resource found，可以参考该文章解决： init –service-account tiller –output yaml | sed ‘s@apiVersion: extensions/v1beta1@apiVersion: apps/v1@’ | sed ‘s@ replicas: 1@ replicas: 1\n selector: {“matchLabels”: {“app”: “helm”, “name”: “tiller”}}@’ | kubectl apply -f -</span></h5><h5><span id="5-主节点-kubeadm-init完成后务必按照提示创建配置目录">5. 主节点 kubeadm init完成后，务必按照提示，创建配置目录：</span></h5><p>mkdir -p $HOME/.kube<br>sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<br>sudo chown $(id -u):$(id -g) $HOME/.kube/config</p><h5><span id="6-为了使dashboard能正常显示监控数据可以安装heapster">6. 为了使dashboard能正常显示监控数据，可以安装heapster：</span></h5><p>参考：<a href="https://blog.csdn.net/qianghaohao/article/details/98859392">https://blog.csdn.net/qianghaohao/article/details/98859392</a></p><p>一些机器原始设置备份：<br>/etc/default/grub 原始配置备份：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GRUB_TIMEOUT=5</span><br><span class="line">GRUB_DISTRIBUTOR=&quot;$(sed &#x27;s, release .*$,,g&#x27; /etc/system-release)&quot;</span><br><span class="line">GRUB_DEFAULT=saved</span><br><span class="line">GRUB_DISABLE_SUBMENU=true</span><br><span class="line">GRUB_TERMINAL_OUTPUT=&quot;console&quot;</span><br><span class="line">GRUB_CMDLINE_LINUX=&quot;crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet&quot;</span><br><span class="line">GRUB_DISABLE_RECOVERY=&quot;true&quot;</span><br></pre></td></tr></table></figure><p>其他：</p><p>关于ingress ngnix <a href="https://qhh.me/2019/08/12/%E4%BD%BF%E7%94%A8-Kubernetes-Ingress-%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1/">https://qhh.me/2019/08/12/%E4%BD%BF%E7%94%A8-Kubernetes-Ingress-%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1/</a></p><p>获取dashboard登录token：<br>kubectl -n kube-system get secret | grep kubernetes-dashboard-token<br>kubernetes-dashboard-token-xmzng<br>kubectl describe -n kube-system secret/kubernetes-dashboard-token-xmzng</p><p>kubectl config set-context kubernetes-dashboard@kubernetes –cluster=kubernetes –user=kubernetes-dashboard –kubeconfig=/root/dashbord-admin.conf<br>kubectl config user-context kubernetes-dashboard@kubernets –kubeconfig=/root/dashbord-admin.conf</p><p>上面搭的集群不具备高可用的特性，只有一个master节点，一旦该master挂掉，集群就无法管理了<br>关于高可用k8s集群：<br><a href="https://blog.csdn.net/networken/article/details/89599004">https://blog.csdn.net/networken/article/details/89599004</a><br><a href="https://blog.csdn.net/fanren224/article/details/86573264">https://blog.csdn.net/fanren224/article/details/86573264</a><br><a href="https://blog.51cto.com/billy98/2350660">https://blog.51cto.com/billy98/2350660</a><br><a href="https://www.jianshu.com/p/8eb81d1674dc">https://www.jianshu.com/p/8eb81d1674dc</a><br><a href="https://www.kubernetes.org.cn/5273.html">https://www.kubernetes.org.cn/5273.html</a></p><p>参考：<br>使用kubeadm部署k8s集群： <a href="https://www.kubernetes.org.cn/5551.html">https://www.kubernetes.org.cn/5551.html</a><br><a href="https://www.kubernetes.org.cn/5551.html">https://www.kubernetes.org.cn/5551.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Kubeadm是k8s官方提供的一个k8s集群搭建和管理工具，能简化很多配置工作。&lt;/p&gt;
&lt;p&gt;参考： &lt;a href=&quot;https://kubernetes.io/zh/docs/reference/setup-tools/kubeadm/kubeadm/&quot;&gt;https</summary>
      
    
    
    
    <category term="Technology" scheme="http://example.com/categories/Technology/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于Redis分布式锁以及Redisson的用法</title>
    <link href="http://example.com/2020/02/01/distribute_lock_redisson/"/>
    <id>http://example.com/2020/02/01/distribute_lock_redisson/</id>
    <published>2020-02-01T05:32:33.000Z</published>
    <updated>2021-06-21T06:38:19.294Z</updated>
    
    <content type="html"><![CDATA[<p>Redis分布式锁思路一般是通过setnx命令，该命令含义为set if not exist，也就是key不存在则设值，存在则不作任何处理，返回值为：</p><ul><li>1 key 不存在，被成功设值</li><li>0 key 已存在，设值失败，不作处理</li></ul><p>通过判断setnx的返回值，如果是0，说明已经其他线程加锁成功，需要等待，如果是1，则本线程加锁成功，进入临界区访问资源，并设值key的有效时间，防止key一直不释放，造成死锁。</p><p>由于setnx的特性，等待锁的线程可以一直循环执行该命令检测锁的状态。</p><span id="more"></span><h3><span id="1-redis分布式锁的错误示范">1 Redis分布式锁的错误示范</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码</span></span><br><span class="line">result = jedis.setnx(<span class="string">&quot;lock_key&quot;</span>, <span class="string">&quot;current_timestamp&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> result:</span><br><span class="line">jedis.expire(<span class="string">&quot;lock_key&quot;</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><ul><li>问题1：setnx和expire不是原子操作，如果setnx后出现异常，expire一直没执行，key就一直不会释放，造成死锁。</li><li>问题2：对value没有检查，可能会导致别的线程解锁当前线程设置的锁。</li></ul><p>对于原子性问题，可以在新版本redis使用set命令，set(key,value,option,expiretime), 一条命令可以实现setnx的同时设置expiretime</p><p>对于 value问题，可以将value设置为当前加锁对象的标识，在解锁时判断value与自身标识是否一致。但是这里涉及到一个getvalue和deletekey双重操作，必须要保证原子性, 否则getvalue比较后，出现异常，delete操作就不会执行，锁也一直无法释放，考虑使用lua脚本来做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放分布式锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uniqueId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseLock</span><span class="params">(String key, String uniqueId)</span> </span>&#123;</span><br><span class="line">    String luaScript = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then &quot;</span> +</span><br><span class="line">            <span class="string">&quot;return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(uniqueId)).equals(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="2-redisson的用法">2 Redisson的用法</span></h3><p>github: <a href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></p><p>maven:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.1 单机模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonClient</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useClusterServers().addNodeAddress(<span class="string">&quot;redis://&quot;</span> + host + <span class="string">&quot;:&quot;</span> + port).setScanInterval(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2.2 cluster模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.redteamobile.stat.configuration;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.redis.cluster&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisClusterProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String nodes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer commandTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer maxAttempts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer maxRedirects;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer maxActive;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer maxWait;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer maxIdle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer minIdle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> testOnBorrow;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonClient</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        String[] cNodes = redisClusterProperties.getNodes().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        List&lt;String&gt; nodes = Arrays.asList(cNodes).stream().map(cNode -&gt; <span class="string">&quot;redis://&quot;</span> + cNode).collect(Collectors.toList());</span><br><span class="line">        config.useClusterServers().addNodeAddress(nodes.toArray(<span class="keyword">new</span> String[nodes.size()])).setScanInterval(<span class="number">5000</span>);</span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  redis:</span><br><span class="line">#    cluster:</span><br><span class="line">#      # 各 Redis 节点信息 192.168.117.135:6379,192.168.117.135:6380,192.168.117.136:7379,192.168.117.136:7380,192.168.117.137:8379,192.168.117.137:8380</span><br><span class="line">#      nodes: 10.244.1.3:6379,10.244.2.3:6379,10.244.0.7:6379,10.244.2.4:6379,10.244.1.5:6379,10.244.1.6:6379</span><br><span class="line">#      # 执行命令超时时间</span><br><span class="line">#      command-timeout: 15000</span><br><span class="line">#      # 重试次数</span><br><span class="line">#      max-attempts: 5</span><br><span class="line">#      # 跨集群执行命令时要遵循的最大重定向数量</span><br><span class="line">#      max-redirects: 3</span><br><span class="line">#      # 连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">#      max-active: 16</span><br><span class="line">#      # 连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">#      max-wait: -1</span><br><span class="line">#      # 连接池中的最大空闲连接</span><br><span class="line">#      max-idle: 8</span><br><span class="line">#      # 连接池中的最小空闲连接</span><br><span class="line">#      min-idle: 0</span><br><span class="line">#      # 是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个</span><br><span class="line">#      test-on-borrow: true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.3 哨兵模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Config config = <span class="keyword">new</span> Config();</span><br><span class="line">config.useSentinelServers().addSentinelAddress(</span><br><span class="line">        <span class="string">&quot;redis://172.29.3.245:26378&quot;</span>,<span class="string">&quot;redis://172.29.3.245:26379&quot;</span>, <span class="string">&quot;redis://172.29.3.245:26380&quot;</span>)</span><br><span class="line">        .setMasterName(<span class="string">&quot;mymaster&quot;</span>)</span><br><span class="line">        .setPassword(<span class="string">&quot;a123456&quot;</span>).setDatabase(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>2.4 RedLock</p><p>注意上面三种都是针对同一个redis集群的，如果有大型系统使用多个redis集群（注意是多个集群，不是多个实例），要获取多集群redis分布式锁，可以考虑使用Redlock(假设每个集群只有一个redis实例)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Config config1 = new Config();</span><br><span class="line">config1.useSingleServer().setAddress(&quot;redis://172.29.1.180:5378&quot;)</span><br><span class="line">        .setPassword(&quot;a123456&quot;).setDatabase(0);</span><br><span class="line">RedissonClient redissonClient1 = Redisson.create(config1);</span><br><span class="line"></span><br><span class="line">Config config2 = new Config();</span><br><span class="line">config2.useSingleServer().setAddress(&quot;redis://172.29.1.180:5379&quot;)</span><br><span class="line">        .setPassword(&quot;a123456&quot;).setDatabase(0);</span><br><span class="line">RedissonClient redissonClient2 = Redisson.create(config2);</span><br><span class="line"></span><br><span class="line">Config config3 = new Config();</span><br><span class="line">config3.useSingleServer().setAddress(&quot;redis://172.29.1.180:5380&quot;)</span><br><span class="line">        .setPassword(&quot;a123456&quot;).setDatabase(0);</span><br><span class="line">RedissonClient redissonClient3 = Redisson.create(config3);</span><br><span class="line"></span><br><span class="line">String resourceName = &quot;REDLOCK&quot;;</span><br><span class="line">RLock lock1 = redissonClient1.getLock(resourceName);</span><br><span class="line">RLock lock2 = redissonClient2.getLock(resourceName);</span><br><span class="line">RLock lock3 = redissonClient3.getLock(resourceName);</span><br><span class="line"></span><br><span class="line">RedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);</span><br><span class="line">boolean isLock;</span><br><span class="line">try &#123;</span><br><span class="line">    isLock = redLock.tryLock(500, 30000, TimeUnit.MILLISECONDS);</span><br><span class="line">    System.out.println(&quot;isLock = &quot;+isLock);</span><br><span class="line">    if (isLock) &#123;</span><br><span class="line">        //TODO if get lock success, do something;</span><br><span class="line">        Thread.sleep(30000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    // 无论如何, 最后都要解锁</span><br><span class="line">    System.out.println(&quot;&quot;);</span><br><span class="line">    redLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Redlock RedissonRedLock redLock = new RedissonRedLock(lock1, lock2, lock3);</p><p>2.5 获取锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redissonClient.getLock(LOCK_NAME);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isLock = lock.tryLock(LOCK_ACQUIRE_TIME_OUT_IN_SECONDS, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (!isLock)</span><br><span class="line">            &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;get distribute lock failed&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;collect stat data failed&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>redisson RLOCK接口方法说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RRLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//----------------------Lock接口方法-----------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁 锁的有效期默认30秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false .</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，</span></span><br><span class="line"><span class="comment">     * 在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位 小时、分、秒、毫秒等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中断锁 表示该锁可以被中断 假如A和B同时调这个方法，A获取锁，B为获取锁，那么B线程可以通过</span></span><br><span class="line"><span class="comment">     * Thread.currentThread().interrupt(); 方法真正中断该线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------RLock接口方法-----------------------</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁 上面是默认30秒这里可以手动设置锁的有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁有效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit      时间单位 小时、分、秒、毫秒等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里比上面多一个参数，多添加一个锁的有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> waitTime  等待时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime 锁有效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit      时间单位 小时、分、秒、毫秒等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> waitTime, <span class="keyword">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检验该锁是否被线程使用，如果被使用返回True</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查当前线程是否获得此锁（这个和上面的区别就是该方法可以判断是否当前线程获得此锁，而不是此锁是否被线程占有）</span></span><br><span class="line"><span class="comment">     * 这个比上面那个实用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中断锁 和上面中断锁差不多，只是这里如果获得锁成功,添加锁的有效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTime  锁有效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit       时间单位 小时、分、秒、毫秒等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit)</span></span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.javazhiyin.com/29459.html">Redisson实现Redis分布式锁的N种姿势</a></p><p><a href="https://www.cnblogs.com/cjsblog/p/11273205.html">Redisson基本用法</a></p><p><a href="https://www.cnblogs.com/qdhxhz/p/11055426.html">Redisson实现分布式锁(2)—RedissonLock</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis分布式锁思路一般是通过setnx命令，该命令含义为set if not exist，也就是key不存在则设值，存在则不作任何处理，返回值为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 key 不存在，被成功设值&lt;/li&gt;
&lt;li&gt;0 key 已存在，设值失败，不作处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过判断setnx的返回值，如果是0，说明已经其他线程加锁成功，需要等待，如果是1，则本线程加锁成功，进入临界区访问资源，并设值key的有效时间，防止key一直不释放，造成死锁。&lt;/p&gt;
&lt;p&gt;由于setnx的特性，等待锁的线程可以一直循环执行该命令检测锁的状态。&lt;/p&gt;</summary>
    
    
    
    <category term="Technology" scheme="http://example.com/categories/Technology/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用redistemplate调用lua脚本实现的redis计数器</title>
    <link href="http://example.com/2020/02/01/redis_lua_counter/"/>
    <id>http://example.com/2020/02/01/redis_lua_counter/</id>
    <published>2020-02-01T05:30:33.000Z</published>
    <updated>2021-06-21T06:38:19.765Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="redistemplate执行lua脚本的方式">redistemplate执行lua脚本的方式</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.redteamobile.stat.redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scripting.support.StaticScriptSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> RedisCounter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> zijian zhao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/1/14 11:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCounter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;redisTemplate&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DEFAULT_EXPIRE_TIME_IN_SECONDS = <span class="number">60</span> * <span class="number">60</span> * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LUA_INCR_EXPIRE_ATOMIC_SCRIPT =</span><br><span class="line">            <span class="string">&quot;local current = redis.call(&#x27;incrBy&#x27;,KEYS[1],ARGV[1]);&quot;</span> +</span><br><span class="line">            <span class="string">&quot; if current == tonumber(ARGV[1]) then&quot;</span> +</span><br><span class="line">            <span class="string">&quot; local t = redis.call(&#x27;ttl&#x27;,KEYS[1]);&quot;</span> +</span><br><span class="line">            <span class="string">&quot; if t == -1 then &quot;</span> +</span><br><span class="line">            <span class="string">&quot; redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2])&quot;</span> +</span><br><span class="line">            <span class="string">&quot; end;&quot;</span> +</span><br><span class="line">            <span class="string">&quot; end;&quot;</span> +</span><br><span class="line">            <span class="string">&quot; return current&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis计数器 使用lua脚本保证incr操作和expire操作的原子性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键值对key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> step 步长</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defaultExpire  失效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">incrBy</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> Integer step, <span class="keyword">final</span> Integer defaultExpire)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            DefaultRedisScript&lt;Long&gt; script = <span class="keyword">new</span> DefaultRedisScript&lt;Long&gt;();</span><br><span class="line">            script.setResultType(Long.class);</span><br><span class="line">            script.setScriptSource(<span class="keyword">new</span> StaticScriptSource(LUA_INCR_EXPIRE_ATOMIC_SCRIPT));</span><br><span class="line">            <span class="keyword">return</span> (Long) redisTemplate.execute(script, Arrays.asList(key), step, defaultExpire);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;redis counter incr failed&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="在redis中使用lua脚本的命令格式">在redis中使用lua脚本的命令格式</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval lua-script key-num [key1 key2 key3 ....] [value1 value2 value3 ....]</span><br></pre></td></tr></table></figure><ul><li>eval 是redis提供的执行lua脚本的命令</li><li>lua-script为字符串形式lua脚本</li><li>key-num标识后面key列表里key的个数，如果没有key，写0，该参数是用来区分后面的key和value的。</li><li>key 列表，会作为参数传递给lua脚本，需要和key-num数量保持一致</li><li>value 列表，也是作为参数传递给lua脚本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval &quot;redis.call(&#x27;set&#x27;,KEYS[1],ARGV[1])&quot; 1 lua-key lua-value</span><br></pre></td></tr></table></figure><p>在lua脚本里，使用KEYS[index] 来获取 eval命令中的 key列表参数， 使用ARGV[INDEX]获取eval命令中的value列表参数。注意这里的index都是从1开始的。</p><p>lua中调用redis命令的语法为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.call(&#x27;command_name&#x27;, [param1, param2,])</span><br></pre></td></tr></table></figure><p>实际行lua脚本中执行redis命令还有一个redis.pcall()命令，两者的区别在于redis.call执行出错会直接raise错误，脚本停止执行，redis.pcall则不会raise错误，返回一个lua的table对象指示错误。</p><p>关于evalsha命令:</p><p>evalsha和eval都可以用来执行lua脚本，区别在于eval执行的是原始的lua脚本，而evalsha为sha-1签名过的lua脚本，用法为首先用该命令给指定lua脚本生成一个sha-1签名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将一个脚本装入脚本缓存，但并不立即运行它</span><br><span class="line">script load lua-script</span><br></pre></td></tr></table></figure><p>得到返回的签名后，就可以用evalsha 加该签名来执行lua脚本，优点在于 如果有些脚本很长，且频繁要被执行，每次传输原始脚本效率不高，而sha-1后的签名会缓存在redis服务端，后续只需要传一个32位的sha-1签名，提高传输效率和性能</p><p>刷新脚本缓存是显式地调用 SCRIPT FLUSH 命令，会清空运行过的所有脚本的缓存</p><p>参考：</p><p><a href="http://redisdoc.com/script/eval.html">EVAL script numkeys key [key …] arg [arg …]</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;redistemplate执行lua脚本的方式&quot;&gt;redistemplate执行lua脚本的方式&lt;/span&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;</summary>
      
    
    
    
    <category term="Technology" scheme="http://example.com/categories/Technology/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>说说加密算法</title>
    <link href="http://example.com/2020/02/01/encrypt_alg/"/>
    <id>http://example.com/2020/02/01/encrypt_alg/</id>
    <published>2020-02-01T05:28:33.000Z</published>
    <updated>2021-06-21T06:38:19.394Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="md5-sha-1-sha-2-sha-3">MD5 SHA-1  SHA-2 SHA-3</span></h3><p>这些都属于hash算法，特点都是可以将任意文本（不太严谨，最大还是有长度限制的，比如SHA-1最大为2的64次方位）转换为一个固定长度的字符串，SHA-1比如固定为160位。不同的源字符串，最后生成的签名都不一样（理论上，实际上有hash碰撞，只是概率极小，需要极大的算力），所以可以使用hash摘要算法来校验原始文本或文件的完整性。</p><p>SHA-1 是摘要算法的一种，目前已经不再安全，有充足计算资源的攻击者可以暴力破解，它签名的结果为160个比特位，除以8对应20个字节，通常我们表示的时候表示为16进制数，160除以4，表示为40位16进制字符串。</p><p>MD5 签名结果为128个比特位，16字节， 32个16进制数字。</p><p>SHA-2 表示了一组hash算法，包括SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256<br>后面的数字表示了散列结果的位数，位数越多，发生hhash碰撞的概率就越低，就更安全。SHA-256  SHA-512是常用的摘要算法。</p><p>SHA-3 是第三代hash算法，使用Keccak算法。SHA3-224 SHA3-256 SHA3-384 SHA3-512</p><p>MD5和SHA-0 SHA-1目前都是不安全，不推荐的摘要算法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;md5-sha-1-sha-2-sha-3&quot;&gt;MD5 SHA-1  SHA-2 SHA-3&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;这些都属于hash算法，特点都是可以将任意文本（不太严谨，最大还是有长度限制的，比如SHA-1最大为2的64次方位）转换为一个固定长</summary>
      
    
    
    
    <category term="Technology" scheme="http://example.com/categories/Technology/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>电信领域几个名词的理解(IMSI ICCID IMEI)</title>
    <link href="http://example.com/2020/02/01/imsi_iccid_imei/"/>
    <id>http://example.com/2020/02/01/imsi_iccid_imei/</id>
    <published>2020-02-01T05:24:33.000Z</published>
    <updated>2021-06-21T06:38:19.432Z</updated>
    
    <content type="html"><![CDATA[<p>IMSI： 移动用户唯一识别码，存在SIM卡里，是用户的标识，IMSI会和KI一起去运营商网络里做认证，认证通过后即可上网。</p><p>ICCID： ICCID 集成电路卡识别码，存在SIM卡里，是卡的标识，或者叫序列号， ICCID和IMSI可以类比为，ICCID相当于身份证卡片的序列号，换身份证后，卡序列号可能会变，但是IMSI相当于一个人的身份证号，不论怎么换卡，身份证号都不会变。ICCID只是用来区别SIM卡，不作接入网络的鉴权认证，可以伪造，可以用一张空白多号卡，写入IMSI和KI，只要是经过破解的IMSI和KI，就可以接入网络，而ICCID可以任意20位数字。实际上，软SIM，就是可以通过以软件方式实现IMSI+KI去认证，有多个IMSI+KI就可以实现一卡多号的能力。默认20位。</p><p>IMEI：移动设备识别码，是硬件设备，如手机，的硬件设备唯一识别码，IMEI从生产厂商到零售用户一套生产线都会被记录。默认15位。</p><p>ps：对于iphone：</p><p>iPhone在激活的时候，会把ICCID和IMSI一起发送到苹果服务器端进行验证。特别是有锁的手机，就使用IMSI来判断是否合法运营商，如果不合法，就无法激活。ICCID作为SIM卡标识，在激活的时候被记录下来，直到下次刷机，在服务端的记录都不会被改变</p><p>ps:</p><p>IMEI现在绝大部分都是英国的授权机构BABT分配的，有意思的是维基百科里有这么一段：</p><p>由于中国制造的手机以低廉价格威胁到了欧洲国际大厂的生存，现在欧洲对中国产手机的IMEI收费从原来的免费到每个机型2000美金</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;IMSI： 移动用户唯一识别码，存在SIM卡里，是用户的标识，IMSI会和KI一起去运营商网络里做认证，认证通过后即可上网。&lt;/p&gt;
&lt;p&gt;ICCID： ICCID 集成电路卡识别码，存在SIM卡里，是卡的标识，或者叫序列号， ICCID和IMSI可以类比为，ICCID相当</summary>
      
    
    
    
    <category term="Technology" scheme="http://example.com/categories/Technology/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes中的计量单位</title>
    <link href="http://example.com/2020/02/01/k8s_meter_unit/"/>
    <id>http://example.com/2020/02/01/k8s_meter_unit/</id>
    <published>2020-02-01T05:24:33.000Z</published>
    <updated>2021-06-21T06:38:19.610Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="cpu-计量">CPU 计量</span></h3><p>CPU 资源的限制和请求以 cpu 为单位。</p><p>Kubernetes 中的一个 cpu 等于：</p><p>1 AWS vCPU<br>1 GCP Core<br>1 Azure vCore<br>1 Hyperthread 在带有超线程的裸机 Intel 处理器上</p><p>CPU 总是要用绝对数量，不可以使用相对数量；0.1 的 CPU 在单核、双核、48核的机器中的意义是一样的</p><p>实际使用中，使用m标识一千分之一的cpu，即millicpu，如1000m相当于1cpu，100m相当于0.1cpu。</p><h3><span id="内存计量">内存计量</span></h3><p>十进制单位： E，P，T，G，M，K<br>二进制单位： Ei，Pi，Ti ，Gi，Mi，Ki</p><p>举例M和Mi的区别在于，1M 相当于 1000 * 1000 bytes<br>1Mi相当于 1024 * 1024 bytes</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;cpu-计量&quot;&gt;CPU 计量&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;CPU 资源的限制和请求以 cpu 为单位。&lt;/p&gt;
&lt;p&gt;Kubernetes 中的一个 cpu 等于：&lt;/p&gt;
&lt;p&gt;1 AWS vCPU&lt;br&gt;1 GCP Core&lt;br&gt;1 Azure </summary>
      
    
    
    
    <category term="Technology" scheme="http://example.com/categories/Technology/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis批量insert数据的写法</title>
    <link href="http://example.com/2020/02/01/mybatis_batch_oper/"/>
    <id>http://example.com/2020/02/01/mybatis_batch_oper/</id>
    <published>2020-02-01T05:24:33.000Z</published>
    <updated>2021-06-21T06:38:19.679Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="xml文件">XML文件</span></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;batchInsertStatMins&quot;</span>&gt;</span></span><br><span class="line">       INSERT INTO stat_min(measure_type,collect_time,value,description)</span><br><span class="line">       VALUES</span><br><span class="line">       <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;statMins&quot;</span> <span class="attr">item</span>=<span class="string">&quot;min&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">           (#&#123;min.measureType&#125;,#&#123;min.collectTime&#125;,#&#123;min.value&#125;,#&#123;min.description&#125;)</span><br><span class="line">       <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于foreach：</p><ul><li>collection：指定要遍历的集合，对应mapper中传入的collection类型的参数名称</li><li>list类型的参数会特殊处理封装在map中，map的key就叫list</li><li>item：将当前遍历出的元素赋值给指定的变量</li><li>separator:每个元素之间的分隔符</li><li>open：遍历出所有结果拼接一个开始的字符</li><li>close:遍历出所有结果拼接一个结束的字符</li><li>index:索引。遍历list的时候是index就是索引，item就是当前值，遍历map的时候index表示的就是map的key，item就是map的值</li><li>#{变量名}</li></ul><h3><span id="mapper">Mapper</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">batchInsertStatMins</span><span class="params">(<span class="meta">@Param(&quot;statMins&quot;)</span> List&lt;StatMin&gt; statMins)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回insert成功的行数</p><h3><span id="关于返回值">关于返回值</span></h3><p>insert update delete 默认返回都是受影响的行数。</p><p>有些文章里说的，insert单条语句返回值是null的说法是不对的，另外，insert操作加<selectkey>来指明返回的主键值有待验证。</selectkey></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;xml文件&quot;&gt;XML文件&lt;/span&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span </summary>
      
    
    
    
    <category term="Technology" scheme="http://example.com/categories/Technology/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>不可能完成的年度计划之2020篇</title>
    <link href="http://example.com/2020/01/01/2020/"/>
    <id>http://example.com/2020/01/01/2020/</id>
    <published>2020-01-01T11:46:38.000Z</published>
    <updated>2021-06-21T06:38:18.759Z</updated>
    
    <content type="html"><![CDATA[<p>生活上：</p><ul><li>多喝水 不要一直盯着电脑 适度休息眼睛</li><li>每周给家里打电话</li><li>条件允许的情况 不要熬夜</li><li>减少不必要的消费 </li></ul><p>个人成长：</p><ul><li>每周写两篇技术博客 </li><li>摄影 后期 PS 调色</li><li>素描或水彩画</li><li>能在全年都为面试做好准备</li></ul><p>旅行：</p><ul><li>重庆和云南</li></ul><p>今年的目标就很简单和粗暴，就是实现财务自由，earn more money。</p><p>so，move on，用1000个小时专注一件事，成为专家。</p><p>2020的slogan是：</p><p>做个行动派 更果敢</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;生活上：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多喝水 不要一直盯着电脑 适度休息眼睛&lt;/li&gt;
&lt;li&gt;每周给家里打电话&lt;/li&gt;
&lt;li&gt;条件允许的情况 不要熬夜&lt;/li&gt;
&lt;li&gt;减少不必要的消费 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;个人成长：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每周写两篇技术</summary>
      
    
    
    
    <category term="Emotion" scheme="http://example.com/categories/Emotion/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>对CI CD 微服务的一些理解</title>
    <link href="http://example.com/2019/10/20/CI_CD_microservice/"/>
    <id>http://example.com/2019/10/20/CI_CD_microservice/</id>
    <published>2019-10-20T04:54:33.000Z</published>
    <updated>2021-06-21T06:38:18.936Z</updated>
    
    <content type="html"><![CDATA[<p>CI CD Devops是敏捷开发模式的几个概念，实现的核心都是自动化技术。<br>CI 就是持续集成，即将代码入库后，工具监测到变更，自动触发的构建，执行单元测试等一系列工作，目的就是能够将最新的变更频繁有效的合入主干，保证合入质量的方式包括持续集成前的代码检视，如gerrit工具，还有持续集成过程中的构建和自动执行单元测试。<br>持续集成的好处在于 本地的需求变更能够更快速的反映到主干，适应快速迭代的开发节奏，这样可以更快更早的发现错误及时应对，也防止分支代码大量偏离主干。</p><span id="more"></span><p>CD 有两个概念，一个是持续部署（Continuous Deployment），一个是持续交付（Continuous Delivery）。 持续部署就是通过自动化工具，能够将CI集成出的可用软件包版本快速部署到测试和生产环境上，提供给client使用； 持续交付则是持续集成+持续测试+持续部署一整套管道。持续交付强调的是，不管怎么更新，软件都是随时可以交付的。</p><p>DevOps 来自于Development和Operations的组合，突出开发和运维的沟通合作，通过自动化流程来使得软件构建、测试、发布更加快捷、频繁和可靠。DevOps可以认为是一个指导敏捷开发的开发理念，它基于CI CD这些基础能力。</p><p>微服务架构的几个特点：</p><ol><li>跑在自己的进程里</li><li>分布式部署</li><li>语言无关性</li><li>解构，独立开发 独立部署 有独立的开发 集成 部署周期</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;CI CD Devops是敏捷开发模式的几个概念，实现的核心都是自动化技术。&lt;br&gt;CI 就是持续集成，即将代码入库后，工具监测到变更，自动触发的构建，执行单元测试等一系列工作，目的就是能够将最新的变更频繁有效的合入主干，保证合入质量的方式包括持续集成前的代码检视，如gerrit工具，还有持续集成过程中的构建和自动执行单元测试。&lt;br&gt;持续集成的好处在于 本地的需求变更能够更快速的反映到主干，适应快速迭代的开发节奏，这样可以更快更早的发现错误及时应对，也防止分支代码大量偏离主干。&lt;/p&gt;</summary>
    
    
    
    <category term="Technology" scheme="http://example.com/categories/Technology/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于load average 指标</title>
    <link href="http://example.com/2019/10/19/loadaverage/"/>
    <id>http://example.com/2019/10/19/loadaverage/</id>
    <published>2019-10-19T08:54:33.000Z</published>
    <updated>2021-06-21T06:38:19.633Z</updated>
    
    <content type="html"><![CDATA[<p>被人问到top等命令显示的load average 指标，自己在系统和JVM监控方面还有很多知识盲区，故总结如下。</p><h4><span id="如何查看load-average">如何查看load average？</span></h4><ul><li>uptime</li><li>top</li><li>w</li></ul><h4><span id="load-average-表示什么怎样计算的">load average 表示什么？怎样计算的？</span></h4><p>load average 显示为： <code>load average: 0.40, 0.58, 0.27</code></p><p>load average 表示 正在运行的进程 + 准备好等待运行的进程在特定时间内（1分钟，5分钟，10分钟）的平均进程数（比如现在系统有2个正在运行的进程，3个可运行进程，那么系统的load就是5）。这里的平均是说系统每5s采样一次（Linux），在1分钟/5分钟/10分钟内采样数据的平均值，它统计的是正在运行和进入就绪状态的进程，不包括等待IO、处于wait、被kill的进程，换句话说，是当前所有竞争cpu时间片的进程。</p><p>需要注意的是，这个值它计算的时候没有考虑到cpu核心数，一般来说，多核cpu在看load average的时候，需要用显示的值除以cpu核心数，才能得到有意义的参考值。</p><p>使用如下命令查看cpu核心数： <code>cat /proc/cpuinfo |grep &quot;cores&quot;|uniq</code></p><h4><span id="怎样是安全的load-average">怎样是安全的load average？</span></h4><p>一般来说，这个值保持在0.7以下是理想状态，在0.7~1之间虽然暂时看没有问题，但是建议先行分析找出隐患，如果在5以上就说明在超负荷运转了，需要立即排查问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;被人问到top等命令显示的load average 指标，自己在系统和JVM监控方面还有很多知识盲区，故总结如下。&lt;/p&gt;
&lt;h4&gt;&lt;span id=&quot;如何查看load-average&quot;&gt;如何查看load average？&lt;/span&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;uptim</summary>
      
    
    
    
    <category term="Technology" scheme="http://example.com/categories/Technology/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中的阻塞队列</title>
    <link href="http://example.com/2019/10/18/JAVA_blockingqueue/"/>
    <id>http://example.com/2019/10/18/JAVA_blockingqueue/</id>
    <published>2019-10-18T09:54:33.000Z</published>
    <updated>2021-06-21T06:38:19.574Z</updated>
    
    <content type="html"><![CDATA[<h4><span id="继承关系">继承关系</span></h4><p>BlockingQueue(interface)—–&gt;Queue(interface)—–&gt;Collection(interface)</p><h4><span id="blockingqueue接口提供的方法">BlockingQueue接口提供的方法</span></h4><p>可以分为三类：</p><ul><li>add remove element 这三个方法的特点是如果操作不成功直接抛出异常</li><li>offer poll peek 这三个方法的特点是操作不成功不会抛异常，而是返回一个操作成功或失败的结果</li><li>put take 是两个阻塞方法，即操作会一直阻塞，指导成功，比如队列已满进行put操作就会一直等待不会返回</li></ul><p>备注：</p><ul><li>offer和poll 有两个重载的带超时参数的方法，也会阻塞，知道达到超时时间。</li><li>remove poll take 都会移除队列中的元素，并返回该元素</li><li>不能向BlockingQueue插入一个空对象，否则会抛出NullPointerException</li></ul><h4><span id="jdk提供的常见阻塞队列">JDK提供的常见阻塞队列</span></h4><ul><li>ArrayBlockingQueue  FIFO 数组实现的有界阻塞队列，初始化时必须指定长度</li><li>LinkedBlockingQueue FIFO 链表实现的无界阻塞队列，也不是真的无界，初始化时不指定长度则默认为Integer.MAX_VALUE</li><li>PriorityBlockingQueue 不遵循FIFO，而是提供了方法可以按照优先级出队，是一个基于数组的无界队列，插入的元素必须指定Comparator。</li><li>DelayQueue、BlockingDeque 双端队列，可以从任意一端插入或者抽取元素，最大长度Integer.MAX_VALUE</li><li>SynchronousQueue</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4&gt;&lt;span id=&quot;继承关系&quot;&gt;继承关系&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;BlockingQueue(interface)—–&amp;gt;Queue(interface)—–&amp;gt;Collection(interface)&lt;/p&gt;
&lt;h4&gt;&lt;span id=&quot;blockingq</summary>
      
    
    
    
    <category term="Technology" scheme="http://example.com/categories/Technology/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Spring拾遗</title>
    <link href="http://example.com/2019/09/18/Spring_basic/"/>
    <id>http://example.com/2019/09/18/Spring_basic/</id>
    <published>2019-09-18T02:09:33.000Z</published>
    <updated>2021-06-21T06:38:19.820Z</updated>
    
    <content type="html"><![CDATA[<p>spring俨然是java后端框架的基础设施，遗憾的是一直没研究过源码，只停留在使用层面。DI和AOP的原理就不多说了，围绕spring的一些细节，做个总结。</p><h4><span id="1-spring-事务">1 Spring 事务</span></h4><p><a href="https://blog.csdn.net/trigl/article/details/50968079">Spring事务管理</a></p><p><a href="https://www.cnblogs.com/sharpest/p/7995203.html">Spring Boot中的事务管理</a></p><p>网上这两个文章总结的很全面，记录一下比较重要的几个点。</p><ol><li>并发事务操作相同数据引起的三个问题：脏读，不可重复读，幻读。  脏读是一个事务在另一个事务操作未提交的情况下对相同数据进行读取，另一个事务操作完成后，导致第一个事务读取无效。 而不可重复读是指读取多次数据，在两次读取的间隔中，有可能其他事务对数据进行了操作，导致多次读取相同数据的结果不一致。幻读，则是指多次重复读取时，记录条数不一致。 不可重复读和幻读的区别就在于，前者是同一条记录的某些字段可能不一致，后者是表记录的数量可能不一致，也就是他们锁定的粒度不同。前者粒度小，后者粒度打，为了防止幻读，一般是通过锁定整张表来实现，这样会严重影响性能。</li></ol><span id="more"></span><ol start="2"><li>Spring并不直接管理事务，而是提供了统一接口org.springframework.transaction.PlatformTransactionManager，将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现，比如JDBC事务，hibernate事务，JPA事务,JTA事务。默认情况下，数据库持久化操作是自动提交的，事务的概念其实我理解相当于把autocommit设为false，在一系列操作后和发生异常后，通过事务管理器手动去commit和rollback，基于此，其实不适用spring的事务，我们自己通过jdbc等持久化依赖提供的方法也可以自己实现事务管理，只是说spring事务时现成的轮子，我们直接拿来用而已。</li><li>关于隔离级别。5中隔离级别中，default是使用后端数据库默认的隔离级别，大多数情况，这个值等于READ_COMMITTED；READ_COMMITTED是大多数情况采用的，能阻止脏读，但是不能避免不可重复读和幻读，它只允许读取其他事务已经提交的数据。READ_UNCOMMITTED是最低的隔离级别，三个问题都无法避免。 SERIALIZABLE是最高的隔离级别，能避免三个问题，但是性能极差。</li><li>事务分为两种，编程式事务和声明式事务，编程式事务是手动初始化一个dataSourceTransactionManager，并自己写try catch，调用dataSourceTransactionManager的rollback和commit方法来实现的，这种方式可以个性化控制事务的粒度和逻辑，但是这导致事务和业务代码耦合在一起。 而声明式事务是通过AOP方式实现，对业务代码没有侵入，低耦合。</li><li>声明式事务的使用方式。xml配置的话需要先用&lt;tx:annotation-driven transaction-manager=”transactionManager”/&gt;开启事务，然后配置transactionmanager的bean。注解形式，在@Configuration中用@EnableTransactionManagement开启事务，在@Configuration中可以用@Bean定义需要初始化的transactionmanager。最后使用时在需要纳入事务管理的类或方法上通过@transactional注解来标注一个声明式事务(标注在类上，则说明类中所有方法纳入事务管理)。</li><li>事务的传播行为（propagation behavior）。传播行为指的时，如果两个方法都用@transactional标注成事务方法，那一个调用另一个时事务的处理方式。其中最常用的required，表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务，required和required_new的区别在于，required被调用方法会纳入调用方法的事务中，而required_new的被调用方法是一个独立的事务，也就是不属于外层的事务，内层事务执行完就会提交。</li><li>在Spring Boot中，当引入了spring-boot-starter-jdbc或spring-boot-starter-data-jpa依赖，框 架会自动默认分别注入DataSourceTransactionManager或JpaTransactionManager。在springapplication入口类上用@EnableTransactionManagement 开启事务支持，就可以用@Transactional注解进行事务的使用。需要注意的时，当引入的持久化依赖有多个时，有两种处理方式，一个是用@bean手动注入一个需要使用的事务管理器，因为@bean注如的bean会被优先加载，外部依赖中的事务管理器就不会再被加载了。另一个方式是用@transactional注解时，用value指定需要使用的事务管理器的名称。</li></ol><h4><span id="2-关于aop">2 关于AOP</span></h4><ol><li>spring AOP 是基于动态代理的，实现有两个，一个是JDK自带的动态代理，另一个Cglib。 两个的区别在于，JDK动态代理必须基于接口，通过反射来实现，通过JDK提供的<code>lang.reflect.Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>来生成代理类，第一个参数为被代理的类的class，第二个参数为被代理类实现的接口，最后一个参数为InvocationHandler接口的实现类，在该接口的invoke方法中定义自定义的增强功能。  第二个动态代理的实现方式为Cglib，它是通过在底层获取到被代理类的class，通过修改字节码，生成被代理类的子类来实现功能增强的，不需要实现接口，所以泛用性更高。<strong>基于这两种实现方式，那可以得出结论，就是目标类没有实现接口，且class为final修饰时，是无法使用Srping AOP的，因为没有实现接口就不能使用JDK动态代理，而class为final意味着无法被继承，也就无法生成子类，Cglib就无法使用。</strong> 在Spring AOP中，是通过<code>org.springframework.aop.framework.DefaultAopProxyFactory</code>来判断具体使用哪一种代理方式的，判断依据其实就是有接口则使用JDK动态代理，否则用cglib。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.aop.framework;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.aop.SpringProxy;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">            <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                        <span class="comment">//判断如果是接口，或者是被代理的类，则使用JDK动态代理</span></span><br><span class="line">                        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">            &#125;</span><br><span class="line">                        <span class="comment">//否则用cglib动态代理，（没有实现接口的类）</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//默认使用jdk动态代理</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 确定提供的&#123;<span class="doctag">@link</span> AdvisedSupport&#125;是否仅有</span></span><br><span class="line"><span class="comment">        * 指定了&#123;<span class="doctag">@link</span> org.springframework.aop.SpringProxy&#125;接口</span></span><br><span class="line"><span class="comment">        *（或者根本没有指定的代理接口）。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();</span><br><span class="line">        <span class="keyword">return</span> (ifcs.length == <span class="number">0</span> || (ifcs.length == <span class="number">1</span> &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[<span class="number">0</span>])));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>spring AOP 说到底是一种代理，类似于一个拦截器，所以它可以用在比如统一拦截进行参数校验，权限验证，日志记录等等。</li><li>Spring AOP 在使用时，当然也有xml和注解两种，xml就不总结了，感觉注解更方便，需要注意的时使用注解来配置aop，需要依赖AspectJ，AspectJ提供了spring aop的注解支持。启用AspectJ 的方式，通过xml：<a href="aop:aspectj-autoproxy/">aop:aspectj-autoproxy/</a>，通过注解：@Configuration中增加@EnableAspectJAutoProxy注解。使用时，通过@Component和@Aspect注解来标注一个切面bean，在该bean中定义切点。四种切点的定义方法见下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     * returnVal,切点方法执行后的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning(value=&quot;execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))&quot;,returning = &quot;returnVal&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">(Object returnVal)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知....&quot;</span>+returnVal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 可用于执行切点的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知前....&quot;</span>);</span><br><span class="line">        Object obj= (Object) joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知后....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抛出通知</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value=&quot;execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))&quot;,throwing = &quot;e&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowable</span><span class="params">(Throwable e)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;出现异常:msg=&quot;</span>+e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无论什么情况下都会执行的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After(value=&quot;execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;最终通知....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>execution表达式的三种通配符：</p><ul><li>.. ：匹配方法定义中的任意数量的参数，此外还匹配类定义中的任意数量包</li></ul><p>//任意返回值，任意名称，任意参数的公共方法<br>execution(public * <em>(..))<br>//匹配com.zijian.dao包及其子包中所有类中的所有方法<br>within(com.zijian.dao..</em>) </p><ul><li><ul><li>：匹配给定类的任意子类</li></ul></li></ul><p>//匹配实现了DaoUser接口的所有子类的方法<br>within(com.zijian.dao.DaoUser+) </p><ul><li><ul><li>：匹配任意数量的字符</li></ul></li></ul><p>//匹配com.zijian.service包及其子包中所有类的所有方法<br>within(com.zijian.service..<em>)<br>//匹配以set开头，参数为int类型，任意返回值的方法<br>execution(</em> set*(int))   </p><p>参考： <a href="https://www.cnblogs.com/junzi2099/p/8274813.html">https://www.cnblogs.com/junzi2099/p/8274813.html</a></p><h4><span id="3-注解和自动注入">3 注解和自动注入</span></h4><ol><li>@Configuration相当于xml的<beans>配置，在@Configration上可以搭配@ComponentScan和@EnableXXX来配置包扫描路径和启用AOP/事务等特性。在@configration中可以用@Bean手动注入一个bean，这种注入方式很灵活，可以传入参数和做一些自定义的初始化操作，在@Bean上还可以配合@Conditional(xxx.class implemens condition)注解实现有条件的注入，可以通过实现conditoin接口，来自定义条件注入的规则。@Configruation通常也和@Import和@ImportResource注解搭配使用，用于引入其他地方配置的bean，其中@Import可以通过三种方式引入，一是指定{xxx.class,xxx.class}直接引入具体的某些类，二是指定实现ImportSelector接口的类，在springboot的注解中可以找到这种使用方式，三是指定实现ImportBeanDefination接口的类。@ImportResource则可以通过指定xml的路径来引入xml中定义的bean。</beans></li><li>自动装配有两个注解，@Autowired是spring自己的标签，默认按类型注入，即byType，如果有多个type相同的bean，默认会报错，此时有两种解决方式，一是@Qualifier指定要注入的bean id，另一个是在多个type相同的bean上面用@Primary标注优先加载。另一种情况，没有与之type匹配的bean，默认也会注入失败，此时可以用@Autowired(required=false)来标注。 另一个注解是，@Resource,这是个JSR标准提供的自动装配注解，它比@Autowired更灵活，默认按照Name（id）注入，如果按照name找不到匹配的bean，则自动按照byType方式注入，所以更智能一些。</li><li>指定Bean的初始化和销毁方法，有三种方式，一是@Bean(value=xxxx,initMethod=xxx, destroyMethod=xxx)，另一个是在Bean的初始化和销毁方法上用@PostConstructor和PreDestory注解标注，三是可以通过BeanPostProcessor接口拦截所有Bean，针对需要个性化的bean做一些逻辑处理。</li></ol><h4><span id="4-spring加载和注入依赖的过程">4 Spring加载和注入依赖的过程</span></h4><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/SpringBeanInit.png" alt="Spring Bean加载过程"></p><h4><span id="5-aware系列接口">5 Aware系列接口</span></h4><p>Spring提供了一系列Aware接口，通过aware接口可以访问到spring提供的一些内部组件，常用的如ApplicationContextAware接口可以让我们获取到ApplicationContext。其他的aware接口后面学习后再补上。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;spring俨然是java后端框架的基础设施，遗憾的是一直没研究过源码，只停留在使用层面。DI和AOP的原理就不多说了，围绕spring的一些细节，做个总结。&lt;/p&gt;
&lt;h4 id=&quot;1-Spring-事务&quot;&gt;&lt;a href=&quot;#1-Spring-事务&quot; class=&quot;headerlink&quot; title=&quot;1 Spring 事务&quot;&gt;&lt;/a&gt;1 Spring 事务&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/trigl/article/details/50968079&quot;&gt;Spring事务管理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/sharpest/p/7995203.html&quot;&gt;Spring Boot中的事务管理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;网上这两个文章总结的很全面，记录一下比较重要的几个点。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;并发事务操作相同数据引起的三个问题：脏读，不可重复读，幻读。  脏读是一个事务在另一个事务操作未提交的情况下对相同数据进行读取，另一个事务操作完成后，导致第一个事务读取无效。 而不可重复读是指读取多次数据，在两次读取的间隔中，有可能其他事务对数据进行了操作，导致多次读取相同数据的结果不一致。幻读，则是指多次重复读取时，记录条数不一致。 不可重复读和幻读的区别就在于，前者是同一条记录的某些字段可能不一致，后者是表记录的数量可能不一致，也就是他们锁定的粒度不同。前者粒度小，后者粒度打，为了防止幻读，一般是通过锁定整张表来实现，这样会严重影响性能。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Technology" scheme="http://example.com/categories/Technology/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发拾遗</title>
    <link href="http://example.com/2019/09/13/JAVA_concurrent/"/>
    <id>http://example.com/2019/09/13/JAVA_concurrent/</id>
    <published>2019-09-13T13:09:33.000Z</published>
    <updated>2021-06-21T06:38:19.583Z</updated>
    
    <content type="html"><![CDATA[<p>一些容易忘记的知识点，记录一下。</p><ol><li>手动创建线程池的方式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">.setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Common Thread Pool</span></span><br><span class="line">ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>,</span><br><span class="line"><span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line"><span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br></pre></td></tr></table></figure></li><li>ThreadPoolExecutor提供了submit和execute方法，其中submit可以提交runnable和callable两种类型的线程，有返回值，并可以抛出异常到外面，被外层感知。 execute只能提交runnable类型的线程，没有返回值，无法抛出异常，有异常只能在内部处理，这是两者的区别。</li><li>线程池的类图<br><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%B1%BB%E5%9B%BE.png" alt="线程池的类图"></li></ol><p>Excutorservice提供的三种提交线程的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Submits a value-returning task for execution and returns a</span></span><br><span class="line"><span class="comment">     * Future representing the pending results of the task. The</span></span><br><span class="line"><span class="comment">     * Future&#x27;s &#123;<span class="doctag">@code</span> get&#125; method will return the task&#x27;s result upon</span></span><br><span class="line"><span class="comment">     * successful completion.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * If you would like to immediately block waiting</span></span><br><span class="line"><span class="comment">     * for a task, you can use constructions of the form</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> result = exec.submit(aCallable).get();&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note: The &#123;<span class="doctag">@link</span> Executors&#125; class includes a set of methods</span></span><br><span class="line"><span class="comment">     * that can convert some other common closure-like objects,</span></span><br><span class="line"><span class="comment">     * for example, &#123;<span class="doctag">@link</span> java.security.PrivilegedAction&#125; to</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Callable&#125; form so they can be submitted.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to submit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the task&#x27;s result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Future representing pending completion of the task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Submits a Runnable task for execution and returns a Future</span></span><br><span class="line"><span class="comment">     * representing that task. The Future&#x27;s &#123;<span class="doctag">@code</span> get&#125; method will</span></span><br><span class="line"><span class="comment">     * return the given result upon successful completion.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to submit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result the result to return</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Future representing pending completion of the task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Submits a Runnable task for execution and returns a Future</span></span><br><span class="line"><span class="comment">     * representing that task. The Future&#x27;s &#123;<span class="doctag">@code</span> get&#125; method will</span></span><br><span class="line"><span class="comment">     * return &#123;<span class="doctag">@code</span> null&#125; upon &lt;em&gt;successful&lt;/em&gt; completion.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to submit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Future representing pending completion of the task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure><p>Future接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">package</span> java.util.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> var1, TimeUnit var3)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask 实现了RunnalbeFuture，RunnalbeFuture的继承了runnable和future两个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> Future&#125; that is &#123;<span class="doctag">@link</span> Runnable&#125;. Successful execution of</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@code</span> run&#125; method causes completion of the &#123;<span class="doctag">@code</span> Future&#125;</span></span><br><span class="line"><span class="comment"> * and allows access to its results.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> FutureTask</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Executor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; The result type returned by this Future&#x27;s &#123;<span class="doctag">@code</span> get&#125; method</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask的两个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.callable = callable;</span><br><span class="line">            <span class="keyword">this</span>.state = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到FutureTask可以用来包装一个runnable的线程或者一个callable的线程，执行时，可以直接调用futuretask的run方法或者放入线程池执行，因为它实现了future接口，所以即便直接调用run方法执行，也可以通过其自身的get方法获取结果，以及自身的isDone等方法判断执行状态。FutureTask还可以确保即使调用了多次run方法，它都只会执行一次Runnable或者Callable任务。</p><ol start="4"><li>关于线程池的复用，线程池能够提高效率的很重要一点是它能够线程复用，避免了线程频繁创建切换的开销，创建一个线程池的同时就初始化了n个线程，后续有任务被提交到线程池后，这些任务会交给其中的某些线程去执行，某个线程的任务执行完毕后，该线程并不会立即销毁，而是转换为空闲状态继续等待下个任务。引用别的文章中的一句话：<strong>创建线程变成了从线程池获取空闲的线程，关闭线程变成了向池子中归还线程.</strong> 这和直接用Thread的start方法去启动线程的区别在于，直接start会创建一个新的线程，执行完毕后，线程会销毁。线程池的线程复用可能会在使用Threadlocal时带来一些问题，后续研究一下。</li><li>关于线程池的拒绝策略，手动初始化ThreadPoolExecutor时需要指定线程池的拒绝策略，ThreadPoolExecutor类以内部类的形式已经提供了四种拒绝策略的默认实现，这些内部类都实现了RejectedExecutionHandler接口，只需要初始化时指定就可以了。</li></ol><ul><li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </li><li>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li><li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 </li></ul><ol start="6"><li>关于初始化线程池时使用的workQueue（BlockingQueue<runnable> ），其实这个参数的选择很重要，它制定了线程排队的策略以及队列的长度，常见取值有：</runnable></li></ol><ul><li>ArrayBlockingQueue 基于数组的先进先出队列，此队列创建时必须指定大小</li><li>LinkedBlockingQueue  基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE （创建时最好指定长度，不指定容易OOM）</li><li>SynchronousQueue SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，<strong>必须有另一个线程正在等待接收这个元素</strong>，同步队列没有任何内部容量，甚至连一个队列的容量都没有。只有在使用无界线程池或者有饱和策略时才建议使用该队列。 引用其他文章的解释：<em>SynchronousQueue 内部没有容量，但是由于一个插入操作总是对应一个移除操作，反过来同样需要满足。那么一个元素就不会再SynchronousQueue 里面长时间停留，一旦有了插入线程和移除线程，元素很快就从插入线程移交给移除线程。也就是说这更像是一种信道（管道），资源从一个方向快速传递到另一方 向。显然这是一种快速传递元素的方式，也就是说在这种情况下元素总是以最快的方式从插入着（生产者）传递给移除着（消费者），这在多任务队列中是最快处理任务的方式。在线程池里的一个典型应用是Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</em></li><li>PriorityBlockingQueue 带有优先级的阻塞队列</li></ul><p>上面使用SynchronousQueue的线程池与使用其他blockingqueue的线程池区别在于，SynchronousQueue没有缓冲队列，提交到线程池的任务必须有对应的线程接收处理，它没有最大线程数的限制，所以提交的任务过多时，可能会创建大量线程，导致内存溢出等问题，而其他的blockingqueue，提交到线程池的任务过多达到corePoolSize时可以在缓冲队列等待。</p><ol start="7"><li>关于线程池的keepAliveTime参数，表示空闲线程的存活实践，因为线程池时存在线程复用的，已经初始化的线程不会被立即销毁，而是转为空闲状态，这个参数表示这些空闲线程的最大存活时间。</li><li>任务提交给线程池之后的处理处理过程：</li></ol><ul><li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li><li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li><li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li><li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</li></ul><p>参考：</p><ul><li><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html">https://www.cnblogs.com/dolphin0520/p/3932921.html</a></li><li><a href="https://blog.csdn.net/qq_35909080/article/details/87002367">https://blog.csdn.net/qq_35909080/article/details/87002367</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一些容易忘记的知识点，记录一下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手动创建线程池的方式&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;</summary>
      
    
    
    
    <category term="Technology" scheme="http://example.com/categories/Technology/"/>
    
    
    <category term="JAVA 并发" scheme="http://example.com/tags/JAVA-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>设计模式02_工厂模式</title>
    <link href="http://example.com/2019/09/12/design_pattern02_factory/"/>
    <id>http://example.com/2019/09/12/design_pattern02_factory/</id>
    <published>2019-09-12T13:34:23.000Z</published>
    <updated>2021-06-21T06:38:19.113Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.jpg" alt="三种工厂模式的异同"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://md-pic.oss-cn-beijing.aliyuncs.com/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.jpg&quot; alt=&quot;三种工厂模式的异同&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Technology" scheme="http://example.com/categories/Technology/"/>
    
    
    <category term="DesignPattern" scheme="http://example.com/tags/DesignPattern/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件之kafka</title>
    <link href="http://example.com/2019/09/05/kafka/"/>
    <id>http://example.com/2019/09/05/kafka/</id>
    <published>2019-09-05T13:39:26.000Z</published>
    <updated>2021-06-21T06:38:19.621Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="关于kafka">关于kafka</span></h3><p>因为在华为技术线的原因，接触的第一个消息中间件就是kafka，华为选择kafka的原因，推测一是kafka多节点集群式部署方便水平扩展，另一个是可靠性和易用性。 kafka是最初LinkedIn公司用Scala语言开发的一个分布式消息系统，后面被捐赠给了Apache基金会。提到消息队列，最常用的应该就是系统解耦和流量削峰提高吞吐量这两大特性，kafka在此基础上，提供了大多数消息系统难以实现的顺序性保障和回溯消费的功能。</p><h3><span id="kafka中的名词">kafka中的名词</span></h3><ul><li>Producer 生产者</li><li>Consumer 消费者</li><li>Broker 可以认为是一个独立的kafka服务节点或实例，一个或多个Broker组成了kafka集群</li><li>Zookeeper 在kafka集群中负责集群元数据管理和控制节点选举</li><li>Topic kafka中的消息以topic为单位归类，发送和接受消息均需要指定特定的topic，注意topic只是一个逻辑概念，它可以分为多个分区，一个分区只属于单个主题。</li><li>Partition 分区在存储角度可以看做一个可追加的日志文件，消息被追加到log文件时会指定一个特定的偏移量offset，这个offset是消息在分区中的唯一标识。kafka通过这个offset保证消息在分区内的有序性，所以kafka保证的是分区有序，而不是主题有序。分区有副本机制，一主多从，副本会主动从主节点同步数据，可以通过增加副本数量提高集群的容灾能力。</li></ul><h3><span id="安装kafka">安装kafka</span></h3><p>kafka和zookeeper都是基于JVM的服务，所以需要保证先安装了JDK。（kafka基于scala开发，而scala是运行在JVM中的）</p><p>先安装zookeeper：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zookeeper</span><br></pre></td></tr></table></figure><p>从<a href="http://kafka.apache.org/downloads">官网</a>下载kafka安装包，</p><p>待续..</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;关于kafka&quot;&gt;关于kafka&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;因为在华为技术线的原因，接触的第一个消息中间件就是kafka，华为选择kafka的原因，推测一是kafka多节点集群式部署方便水平扩展，另一个是可靠性和易用性。 kafka是最初Linked</summary>
      
    
    
    
    <category term="Technology" scheme="http://example.com/categories/Technology/"/>
    
    
    <category term="框架" scheme="http://example.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>早七点的外事学院</title>
    <link href="http://example.com/2019/09/05/morning_at_institute/"/>
    <id>http://example.com/2019/09/05/morning_at_institute/</id>
    <published>2019-09-05T00:02:55.000Z</published>
    <updated>2021-06-21T06:38:19.647Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/society/waishixueyuan/2019-09-05%2008.55.48%201.jpg"></p><span id="more"></span><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/society/waishixueyuan/2019-09-05%2008.55.48%202.jpg"></p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/society/waishixueyuan/2019-09-05%2008.55.48%203.jpg"></p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/society/waishixueyuan/2019-09-05%2008.55.49%201.jpg"></p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/society/waishixueyuan/2019-09-05%2008.55.49%202.jpg"></p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/society/waishixueyuan/2019-09-05%2008.55.49%203.jpg"></p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/society/waishixueyuan/2019-09-05%2008.55.50%201.jpg"></p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/society/waishixueyuan/2019-09-05%2008.55.50%202.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://md-pic.oss-cn-beijing.aliyuncs.com/society/waishixueyuan/2019-09-05%2008.55.48%201.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="摄影" scheme="http://example.com/categories/%E6%91%84%E5%BD%B1/"/>
    
    
    <category term="摄影 人文" scheme="http://example.com/tags/%E6%91%84%E5%BD%B1-%E4%BA%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>正在消失的鱼化寨</title>
    <link href="http://example.com/2019/09/04/yuhuazhai/"/>
    <id>http://example.com/2019/09/04/yuhuazhai/</id>
    <published>2019-09-04T01:56:55.000Z</published>
    <updated>2021-06-21T06:38:19.894Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/society/2019-09-05%2008.35.27%201.jpg"></p><span id="more"></span><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/society/2019-09-05%2008.38.22%201.jpg"></p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/society/2019-09-05%2008.38.22%202.jpg"></p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/society/2019-09-05%2008.38.22%203.jpg"></p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/society/2019-09-05%2008.38.23%201.jpg"></p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/society/2019-09-05%2008.38.23%202.jpg"></p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/society/2019-09-05%2008.38.23%203.jpg"></p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/society/2019-09-05%2008.47.49%201.jpg"></p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/society/2019-09-05%2008.47.50%201.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://md-pic.oss-cn-beijing.aliyuncs.com/society/2019-09-05%2008.35.27%201.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="摄影" scheme="http://example.com/categories/%E6%91%84%E5%BD%B1/"/>
    
    
    <category term="摄影 人文" scheme="http://example.com/tags/%E6%91%84%E5%BD%B1-%E4%BA%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>八月的温柔</title>
    <link href="http://example.com/2019/09/03/august/"/>
    <id>http://example.com/2019/09/03/august/</id>
    <published>2019-09-03T15:33:55.000Z</published>
    <updated>2021-06-21T06:38:18.848Z</updated>
    
    <content type="html"><![CDATA[<p>一场计划外的严重胃肠感冒扰乱了好几天的节奏，度过了很难受的几天，幸而慢慢好起来。这几天没有精神，原想补补是枝裕和的几部电影，却根本看不下去，今天去操场跑步的时候我才想明白，不是看不进去，是在下意识避免自己受伤，无论是《如父如子》还是《小偷家族》，我喜欢的是他平实朴素的叙事和不加干预的镜头，让人很平静，逃避的是片子里平淡日常背后浓厚的温情，这份温柔是我求而不得的。</p><p>前天看到一句诗:“陌上花开，可缓缓归矣”，是南越王写给自己妻子书信中的一句，我特别喜欢。据说当时南越王在杭州办公，出来看见西湖小径边已经是花红柳绿，不由想着寒食节去娘家祭拜的妻子什么时候回来呀，所以情到深处是平常啊，很羡慕这种单纯美好的爱情。想想自己，年二十又六，一颗老心脏更多的是佛系，我只是再也找不回18岁时奋不顾身投入一份感情的状态了，都随缘吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一场计划外的严重胃肠感冒扰乱了好几天的节奏，度过了很难受的几天，幸而慢慢好起来。这几天没有精神，原想补补是枝裕和的几部电影，却根本看不下去，今天去操场跑步的时候我才想明白，不是看不进去，是在下意识避免自己受伤，无论是《如父如子》还是《小偷家族》，我喜欢的是他平实朴素的叙事和</summary>
      
    
    
    
    <category term="Emotion" scheme="http://example.com/categories/Emotion/"/>
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JAVA技术栈复习笔记14_反射及其应用</title>
    <link href="http://example.com/2019/09/02/JAVA14_reflect/"/>
    <id>http://example.com/2019/09/02/JAVA14_reflect/</id>
    <published>2019-09-02T13:39:26.000Z</published>
    <updated>2021-06-21T06:38:19.565Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="基础用法">基础用法</span></h3><h3><span id="自定义注解与反射">自定义注解与反射</span></h3><h3><span id="动态代理">动态代理</span></h3><h3><span id="spring中的应用">Spring中的应用</span></h3><h3><span id="类加载器和权限验证">类加载器和权限验证</span></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;基础用法&quot;&gt;基础用法&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span id=&quot;自定义注解与反射&quot;&gt;自定义注解与反射&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span id=&quot;动态代理&quot;&gt;动态代理&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span id=&quot;spring中的应用</summary>
      
    
    
    
    <category term="Technology" scheme="http://example.com/categories/Technology/"/>
    
    
    <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>在西藏</title>
    <link href="http://example.com/2019/09/01/tibet/"/>
    <id>http://example.com/2019/09/01/tibet/</id>
    <published>2019-09-01T13:56:55.000Z</published>
    <updated>2021-06-21T06:38:19.861Z</updated>
    
    <content type="html"><![CDATA[<p>8月中旬，临时起意订了去拉萨的机票。一个人出行，并没有什么顾虑，信马由缰。</p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/xizang/20190822135845_IMG_0442-01.jpeg"></p><span id="more"></span><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/xizang/20190823125535_IMG_0455-02.jpeg" alt="拉萨街拍"></p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/xizang/20190823125553_IMG_0458-01.jpeg"></p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/xizang/20190823131441_IMG_0461-01.jpeg"></p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/xizang/20190823131807_IMG_0462-02.jpeg"></p><p><img src="http://md-pic.oss-cn-beijing.aliyuncs.com/xizang/20190823135947_IMG_0469-01.jpeg"></p><p><img src="http://md-pic.oss-cn-beijing.aliyuncs.com/xizang/20190823142103_IMG_0485-01-01.jpeg"></p><p><img src="http://md-pic.oss-cn-beijing.aliyuncs.com/xizang/IMG20190819114221.jpg"></p><p><img src="http://md-pic.oss-cn-beijing.aliyuncs.com/xizang/IMG20190819114246.jpg"></p><p><img src="http://md-pic.oss-cn-beijing.aliyuncs.com/xizang/IMG20190820104927-01.jpeg" alt="林芝南迦巴瓦峰"></p><p><img src="http://md-pic.oss-cn-beijing.aliyuncs.com/xizang/IMG20190820105016-01.jpeg" alt="林芝南迦巴瓦峰"></p><p><img src="http://md-pic.oss-cn-beijing.aliyuncs.com/xizang/IMG20190820113502-01.jpeg" alt="林芝南迦巴瓦峰"></p><p><img src="http://md-pic.oss-cn-beijing.aliyuncs.com/xizang/IMG20190822135135-01.jpeg" alt="羊卓雍措"></p><p><img src="http://md-pic.oss-cn-beijing.aliyuncs.com/xizang/IMG_20190818_214850.jpg"></p><p><img src="http://md-pic.oss-cn-beijing.aliyuncs.com/xizang/IMG_20190818_214914.jpg"></p><p><img src="http://md-pic.oss-cn-beijing.aliyuncs.com/xizang/IMG_20190818_215116.jpg"></p><p><img src="http://md-pic.oss-cn-beijing.aliyuncs.com/xizang/IMG_20190819_155010.jpg"></p><p><img src="http://md-pic.oss-cn-beijing.aliyuncs.com/xizang/IMG_20190819_155138.jpg"></p><p><img src="http://md-pic.oss-cn-beijing.aliyuncs.com/xizang/IMG_20190819_203347-01.jpeg" alt="措木及日湖"></p><p><img src="http://md-pic.oss-cn-beijing.aliyuncs.com/xizang/IMG_20190820_091741-01.jpeg" alt="苯日神山"></p><p><img src="https://md-pic.oss-cn-beijing.aliyuncs.com/xizang/zhumulangma.jpg" alt="珠穆朗玛峰大本营"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;8月中旬，临时起意订了去拉萨的机票。一个人出行，并没有什么顾虑，信马由缰。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://md-pic.oss-cn-beijing.aliyuncs.com/xizang/20190822135845_IMG_0442-01.jpeg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Travel" scheme="http://example.com/categories/Travel/"/>
    
    
    <category term="旅行 西藏 摄影" scheme="http://example.com/tags/%E6%97%85%E8%A1%8C-%E8%A5%BF%E8%97%8F-%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
</feed>
